# Mocking

## Reason for doubling or mocking?
* The real code you need to bypass has **unpredictable behaviour** - for instance, it interacts with an external system or users.
* No need access tokens and any secret information to test
* The **target for doubling doesn't exist yet**
* The **target for doubling is slow**, making unit test run slowly. (Latency issue with server)
    * Digression: Disks (even SSDs) are slow, Networks are glacial
* The **target for doubling interacts with software or hardware that doesn't exist in the unit testing environment.**
* You want to test your test target with cases that are rarely if ever generated by the target for doubling, such as error cases.
* You want to **inspect how the code you're actually testing calls the target for doubling**, and the target doesn't provide facilities for doing this.
* Can help you trust results of your testing

```python

class​ CharCounter:
​'''Class for counting the number of instances of characters in a
file'''
​def​ ​__init__​(self, infile):
  ​"""Construct the class
  Arguments:
  infile: the file object to count
  """
  self.counts = ​{}
  self.buildcounts(infile)

​def​ ​buildcounts​(self, infile):
  ​"""Build the count for a file. This is called by the constructor
  so should not typically be called directly
  """
  chars = infile.read()
  ​for​ char ​in​ chars:
  ​if​ char ​in​ self.counts:
  self.counts[char] += ​1
  ​else​:
  self.counts[char] = ​1

​def​ ​getcount​(self, letter):
  ​"""Look up the count for a particular character
  Arguments:
  letter: the character to get the count for
  Returns: the number of times the letter occurs, which may be
  zero if it is not present
  """
  ​if​ letter ​in​ self.counts:
  ​return​ self.counts[letter]
  ​else​:
  ​return​ 0

``**

## Fakefile

**Example:**
To test the ​CharCounter​ class, we need an object that implements a **read method** that **returns a list (or other iterable) of single-character strings**.

We can use Fakefile as a **stub** (test double) to test CharCounter without actually accessing files:

```python
class​ ​FakeFile​:
  ​def​ ​__init__​(self, contents):
    self.contents = list(contents)

  ​def​ ​read​(self):
    return self.contents
```

```python
from​ charcounter ​import​ CharCounter
from​ fakefile ​import​ FakeFile
import​ unittest
class​ ​CharCounterHandTest​(unittest.TestCase):
  ​def​ ​test_one​(self):
    infile = FakeFile(​"fredfredfred"​)
    counter = CharCounter(infile)

    self.assertEqual(counter.getcount(​"f"​),​ 3​)

    if​__name__==​"__main__"​:
      unittest.main()
```

## Problems

### Problem 1: Intercepting indirect function/method invocations

```python
class​ CharCounter:
  ​ '''Class for counting the number of instances of characters in a
  file'''
  ​def​ ​__init__​(self, inpath):
    ​"""Construct the class
    Arguments:
    inpath: a path to the fil to count
    """
    ​self.counts = ​{}
    self.buildcounts(inpath)

  ​def​ ​buildcounts​(self, inpath):
    """Build the count for a file. This is called by the constructor
    so should not typically be called directly
    """
    infile = open(inpath, ​"r"​)
  ​for​ char ​in​ chars:
  ​if​ char ​in​ self.counts:
  self.counts[char] += ​1
  ​else​:
  self.counts[char] = ​1
  # Rest of the code is unchanged....

```

We can't pass in a ​FakeFile​ object now. 

#### Alternate version of ​CharCounter

Without accessing files, we need to somehow trap calls to ​open()​ and get it to return a test double for ​infile​.

In a statically typed language like Java, replacing the real ​open()​ with a fake ​open()​ would be extremely difficult. It's actually not as hard in Python, as this example (non-test) code demonstrates:

* You have to be very disciplined about the scope of your substitution, as there could be all manner of bugs. This is quite complicated in unit testing, as the test runners may execute your tests in ​any​ order. 

* The code for substituting one function for another was relatively simple. **Substituting an instance method attached to a class results in considerably more complex code**.


```python
from​ fakefile ​import​ FakeFile

def​ ​myopen​(fakefile, fakemode):
  ​return​ FakeFile(​"this is a test"​)

properopen = open

#substitute in the fake open function
open = myopen

#calls the fake open function and prints "this is a test"
myfake = open(​"/proc/version_signature"​,​"r"​)
print(myfake.read()) # Printing the stubbed version of reading and opening a file. It should print This is a test

#switch the real open back in
open = properopen
myreal = open(​"/proc/version_signature"​, "r")
print(myreal.read())


```

### Problem 2: Monitoring the way functions are invoked

The point of unit testing is to check whether the software under test actually behaves as expected. Those expectations **can include that it invokes other code correctly**. To take a very simple example, we might want to check that ​CharCounter​ is opening the file we ask it to count, and that the read mode is "r". Again, it is ​possible​ to handcraft test doubles to do this (if you want to learn about some fairly advanced aspects of Python, it's a good exercise to attempt to do it cleanly), but the code to do so gets **increasingly complex as the checking becomes more elaborate**.

### Problem 3: A maze of twisty little attributes all alike
Often testers are **required to create doubles for every single attribute**, even if you don't ever use the returned values. 

## Mock assertions
### assert_called()
Assert that the mock was called at least once.

```python
>>> mock = Mock()
>>> mock.method()
<Mock name='mock.method()' id='...'>
>>> mock.method.assert_called()
```
### assert_called_once()
Assert that the mock was called exactly once.
```python
mock = Mock()
mock.method()
<Mock name='mock.method()' id='...'>
mock.method.assert_called_once()
mock.method()
<Mock name='mock.method()' id='...'>
mock.method.assert_called_once()
Traceback (most recent call last):
...
AssertionError: Expected 'method' to have been called once. Called 2 times.
```

### assert_called_with(*args, **kwargs)
This method asserts that the last call has been made in a particular way:

```python
mock = Mock()
mock.method(1, 2, 3, test='wow')
<Mock name='mock.method()' id='...'>
mock.method.assert_called_with(1, 2, 3, test='wow')
```

### assert_called_once_with(*args, **kwargs)
Assert that the mock was called exactly once and that call was with the specified arguments.

```python
mock = Mock(return_value=None)
mock('foo', bar='baz')
mock.assert_called_once_with('foo', bar='baz')
mock('other', bar='values')
mock.assert_called_once_with('other', bar='values')
Traceback (most recent call last):
  ...
AssertionError: Expected 'mock' to be called once. Called 2 times.
```

### assert_not_called()
Assert the mock was never called.

```python
m = Mock()
m.hello.assert_not_called()
obj = m.hello()
m.hello.assert_not_called()
Traceback (most recent call last):
  ...
AssertionError: Expected 'hello' to not have been called. Called 1 times.
```

### Speccing a mock
In unittest.Mock() if an attribute does not exist, it will be created for you unless you explicitly delete it (with the ​del​ operator). If you use a ​Mock​ or ​MagicMock​, those attributes will even be callable.
```python
@classmethod
  ​def​ ​setUpClass​(cls):
    realgitlab = gitlab.Gitlab(​'fake@fake.com'​, ​"test"​)
    cls._gitlab = create_autospec(realgitlab)
    gitlabmafia = MagicMock()
    gitlabmafia.name = ​"Team-TheGitLabMafia"
    cls._gitlab.projects.list.return_value = [gitlabmafia]
```

​create_autospec​ does not works off the class definition - it needs an actual object.

Appropriate design can make autospeccing easier - for instance, by setting default values attributes in the class definition where autospec can find them. 


### reset_mock(*, return_value=False, side_effect=False)
The reset_mock method resets all the call attributes on a mock object:

```python
>>> mock = Mock(return_value=None)
>>> mock('hello')
>>> mock.called
True
>>> mock.reset_mock()
>>> mock.called
False
```
### When to check for mocked calls?
* You should check anything that is part of the externally-specified behaviour of the module. (e.g. check if file-access method permissions are correct)

* If it's the only convenient way to verify the correctness of the code you're testing. For example, the parameters of api calls are correct.

* You don't have to check every call to a mock in every single unit test. Sometimes a single test is probably sufficient to check that the mocked method is getting the right arguments.

* **unit tests should have one or two assertions**

### MagicMocks
The ​MagicMock​ class implements many of Python's "magic" functions, including len()​, and returns allegedly sensible default values

### SetUp vs SetUpClass
The difference between the two is that ​setUpClass only runs ​once for each test
class.
```python
class​ ​UtilitiesTest​(unittest.TestCase):
  ​@classmethod
  ​def​ ​setUpClass​(cls):
    cls._gitlab = MagicMock()
    gitlabmafia = MagicMock()
    gitlabmafia.name =​"Team-TheGitLabMafia"
    cls._gitlab.projects.list.return_value=[gitlabmafia]

  ​def​ ​test_basic​(self):
    name = get_first_project_name(self.__class__._gitlab, ​"Team"​)
    self.assertEqual(name, ​"Team-TheGitLabMafia"​)

```
SetUpClass created 3 mocks. First is cls._gitlab, second is gitlabmafia and third mock is created automatically on cls._gitlab.projects.list.return_value.

## Side effects
Mock side effects allow you to retrieve values from a list or other iterable object if the mock is called repeatedly.

## Patches
Mocks an object or method that we **don't have access to directly**.

### Access gitlab.Gitlab object
Helps us to patch every access to ​gitlab.Gitlab​ objects.

```python
import​ gitlab
def​ ​get_first_project_name​(serverURL, token, keyword):
 ​ '''Note: this is not good design - this function is
  even less cohesive than it was previously.
  It's a way to demonstrate patching - no more, no less!
  '''

  gitserver = gitlab.Gitlab(serverURL, token)
  gitserver.auth()
  projects = gitserver.projects.list(owned=​True​,search=keyword)
  ​if​ len(projects) > ​0​:
    ​return​ projects[​0​].name
    ​return​ ​None

  if​ __name__ == ​"__main__"​:
  print(get_first_project_name(​'http://gitlab.com'​,​'Q6ypEE8QbqdeUaf7TAq5'​,​"Team"​))

```

### Hybrid real and mocked patching using create_autospeccing
```python
​def​ ​test_basic​(self):
  realgitlab = gitlab.Gitlab(​"https://gitlab.com"​, ​"faketoken"​)
  ​with​ patch(​'gitlab.Gitlab'​) ​as​ classmock:
    gitlabmafia = MagicMock()
    gitlabmafia.name = ​"Team-TheGitLabMafia"
    gitlabmock = create_autospec(realgitlab)
    gitlabmock.projects.list.return_value = [gitlabmafia]
    classmock.return_value = gitlabmock
    name = get_first_project_name(​"https://gitlab.com"​, "test-token"​, ​"Team"​)
    # Assertions goes here
```

### Patching imported modules

>> ​The key is to patch out SomeClass​ (ed: the thing you're trying to patch)​ where it is used (or where it is looked up). <br />
>> --Mock official documentation
```python
from​ gitlab ​import​ Gitlab

```
So, in this case, rather than patching ​gitlab.Gitlab​, we need to patch <our module name>​.Gitlab​

```python
​def​ ​test_basic​(self):
  realgitlab = gitlab.Gitlab(​"https://gitlab.com"​, ​"faketoken"​)
  ​with​ patch(​'gitlabutilities3.Gitlab'​) as classmock:
  # Mocking goes here..
```

## Mocking alternatives
* hand-roll your own test doubles rather than using the ​mock ​library.
* Docker and local networks if you're mocking something that calls a network service, set up your own version of the service for testing. For instance, rather than mocking gitlab, you set up your own gitlab server, with known test data.
* If you're mocking to avoid user interactions, consider using a tool like Selenium to automate the user interactions, rather than using mocks in the tests themselves.
